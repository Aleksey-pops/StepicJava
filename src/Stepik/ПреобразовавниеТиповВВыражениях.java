package Stepik;

public class ПреобразовавниеТиповВВыражениях {
    public static void main(String[] args) {

        /*
         Преобразование типов в выражениях

При выполнении операции присваивания  выполняется автоматическое (неявное) преобразование типов при условии,
 что оба типа (в левой и правой части оператора) являются совместимыми, а целевой тип (в левой части)
 обладает более широким диапазоном допустимых значений. При этом происходит расширение типа.
 Порядок расширения задается цепочкой:

byte -> short-> int-> long -> float -> double.

int i = 10;
long m=i; //допустимо, int расширяется до long
//short k=i; //ошибка
Однако в Java не все типы данных совместимы, поэтому неявное преобразование типов выполняется не всегда.
 Например, числовые типы и boolean, а также char и boolean не совместимы.

Переменной типа char нельзя присвоить  значение переменной числового типа, но можно присвоить числовой литерал.

 int a=65;
 char c;
//c=a; //ошибка
 c=65;
А вот переменной числового типа (кроме byte и short) можно присвоить значение переменной
типа char (в целевую переменную копируется код символа).

int k;
char sim='A';
k=sim;
//short j=sim; //ошибка
При неявном преобразовании типов int или  long к типам float  и double может
произойти потеря точности. Это иллюстрирует простой пример:

int big = 1234567890;
float f = big;
System.out.printf("%f", f);
В результате на консоль будет выведено 1234567936.000000.

Для явного преобразования типов используется операция приведения, синтаксис которой аналогичен языку C:

(целевой тип) выражение

Например, присвоить переменной типа char код символа, который записан в числовой переменной, можно оператором:

int i=98;
char ch;
ch=(char)i;
При явном преобразовании типов также может возникнуть искажение информации.
Такое искажение бывает двух типов: переполнение (overflow) или потеря значений (underflow).

//Пример overflow:
short maxValue = 256;
byte bb = (byte) maxValue;
System.out.println(bb);
Результат: 0

//Примеры underflow:
double d1 = 0.3333333333333333;
// потеря чисел после точки начиная с 8 знака
float f1 = (float) d1;
System.out.println(f1);
//Результат: 0.33333334

float f3 = 3.64f;
int i3 = (int) f3; // дробная часть отбрасывается
System.out.println(i3);
//Результат: 3
Таким образом, при неправильном использовании явного преобразования типов вся ответственность за это ложится на программиста.

При вычислении сложного выражения типы данных его операндов должны быть совместимы друг с другом.
Например, в одном выражении допускается применение типов short и long, поскольку оба типа являются числовыми.
При вычислении результата операции, в которой участвуют разные типы данных, они преобразуются к одному
общему типу в соответствии с правилами повышения типов (promotion rules):

Сначала все значения типа char, byte и short повышаются до типа int.
А затем выполняется повышение типа выражения до типа с наиболее широким диапазоном согласно цепочке,
 показанной в предыдущем шаге.
Очевидно, что правила повышения типов применяются к значениям, участвующим в выражении, а не к самим переменным.

Иногда повышение типов может приводить к неожиданным результатам. Если, например,
в операции используются два значения типа byte, то перед выполнением операции эти операнды повышаются до int.
Следовательно, результат будет иметь тип int. Если затем необходимо этот результат присвоить переменной типа byte,
то следует использовать операцию явного приведения типов:

byte b;
int i;
b=10;
i=b*b; //приведение не требуется, результат уже повышен до int
b=(byte)(b*b); //требуется приведение типов
Аналогичная ситуация возникает при выполнении операций с символьными операндами.
Например, в следующем фрагменте кода требуется приведение к типу char,
поскольку операнды в выражении повышаются до int:
*/
//char ch1='a', ch2='b';
//ch1=(char)(ch1+ch2);
//        System.out.println(ch1);

//
//        int b= (int) (5/2.);
//        System.out.println(b);
//        double x=3.14; int k= (int) x;
//        System.out.println(k);
////
//        b = (int) (5 / 2.);
//        System.out.println(b);
////
//        double x=3.14; int k=(int)x;
//        System.out.println(k);
////
//        int b= (int) ((int)5/2.);
//        System.out.println(b);
////
//        b = 5 / 2;
//        System.out.println(b);

    }
}
